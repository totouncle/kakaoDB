# macOS 카카오톡 대화 데이터 복호화 파이썬 스크립트 PRD

## 개요 및 목표

macOS용 카카오톡 메신저의 로컬 데이터베이스에 저장된 **채팅 대화 내용을 복호화**하여 사용자가 읽을 수 있는 형태로 추출하는 Python 스크립트를 개발한다. 이 스크립트는 **SQLCipher로 암호화된 카카오톡 DB**에서 우선 **텍스트 채팅 메시지**를 복호화하고, 결과를 새로운 SQLite 데이터베이스로 저장하는 것이 목표이다. 향후 이미지, 첨부파일 등 다른 데이터 유형도 처리할 수 있도록 **확장 가능하고 모듈화된 구조**로 설계한다. 이 PRD는 개발을 위한 상세 요구 사항과 예외 처리 시나리오를 명확히 정의한다.

## 대상 데이터 범위 (텍스트 채팅 우선)

**1. 텍스트 채팅 메시지 우선 복호화:** 초기 버전에서는 **텍스트 형태의 채팅 메시지**만 복호화하여 추출한다. 카카오톡 대화 내용 중 사용자가 주고받은 **문자 메시지**를 중심으로 처리하며, 이 외의 데이터(이미지, 동영상, 파일 첨부 등)는 **후속 버전에서 지원**할 예정이다.

* 데이터 소스: macOS KakaoTalk의 로컬 저장 경로(`~/Library/Containers/com.kakao.KakaoTalkMac/Data/Library/Application Support/com.kakao.KakaoTalkMac/`) 내에 존재하는 **암호화된 채팅 DB 파일**. 이 DB는 카카오톡 대화 내용이 저장된 SQLCipher 암호화 SQLite 파일이다. 해당 경로에서 대상 DB 파일을 식별하여 사용한다 (경로와 파일명은 사용자 입력 또는 알고리즘에 의해 결정됨).
* 처리 대상: 각 채팅방의 **모든 텍스트 메시지 레코드**. 기본적으로 **사용자 본인이 송신하거나 수신한 모든 메시지**를 포함하며, 시스템 메시지(알림 등)도 포함할 수 있다.
* 범위 제한: 초기 단계에서는 텍스트 본문, 발신/수신자 정보, 시간정보 등 **핵심 메타데이터**만 추출한다. **멀티미디어 콘텐츠(이미지, 파일 등)**에 대한 레코드는 후속 개발 시 확장 처리하며, 현재는 해당 레코드의 식별자나 참조 정보만 저장하거나 제외할 수 있다.

이러한 범위 설정을 통해 초기 구현 복잡성을 낮추고, **텍스트 메시지 복호화 성공률과 정확성**에 집중한다. 코드 구조는 이후 **첨부파일, 이미지, 이모티콘, 채팅방 설정** 등의 추가 데이터를 처리하기 쉽게 설계된다.

## 출력 SQLite 데이터베이스 구조

**2. 결과 데이터베이스 스키마:** 복호화된 채팅 데이터는 **새로운 SQLite 데이터베이스**(`kakao_decrypted.db` 등 사용자 지정 경로)에 저장된다. 스키마 설계 시 **카카오톡 원본 DB의 구조**를 참고하되, 필요한 경우 재구성하여 이해하기 쉽게 만든다. 최소한 다음과 같은 **두 개의 주요 테이블**을 포함한다:

* **`rooms` 테이블:** 채팅방(대화방)에 대한 메타정보를 저장한다. 각 레코드는 하나의 채팅방을 나타내며, 주요 필드는 다음과 같다:

  * `room_id` (1차 키): 채팅방을 고유 식별하는 ID. (카카오톡 원본 DB의 채팅방 식별자 활용)
  * `room_name`: 채팅방 이름 또는 제목. (그룹채팅방 이름 또는 1:1채팅의 상대방 이름 등)
  * `created_at`: 채팅방 생성 시간 (가능한 경우 원본 데이터에 존재하면 저장)
  * `member_count`: 채팅방 참여자 수 (필요시; 원본 DB에 별도 테이블이 있으면 추후 확장)
  * 기타: 채팅방 타입(1:1, 그룹, 오픈채팅 등), 공지/설명 등 **원본 DB에서 유의미한 필드**를 참고하여 추가 저장. (예: 오픈채팅 링크나 방장 정보 등은 확장 대상)

* **`messages` 테이블:** 개별 채팅 메시지 기록을 저장한다. 각 레코드는 하나의 메시지를 나타내며, 주요 필드는 다음과 같다:

  * `msg_id` (1차 키): 메시지 고유 ID (원본 DB의 메시지 식별자 사용; 예: NTChatMessage 테이블의 PK).
  * `room_id` (외래 키): 이 메시지가 속한 채팅방의 ID (`rooms.room_id`를 참조). 이를 통해 어떤 채팅방의 대화인지 연결한다.
  * `sender_id`: 발신자 ID 또는 식별자. (자신 혹은 다른 참여자의 식별값; 카카오톡 친구의 경우 내부 ID나 표시 이름)
  * `sender_name`: 발신자 표시 이름 (사용자 친화적으로 보기 위해; 원본 DB에 저장된 별칭이나 프로필 이름 활용 가능).
  * `message_text`: 메시지 본문 내용. 텍스트로 복호화된 채팅 내용이 저장된다.
  * `timestamp`: 메시지 전송 시각. (Unix epoch, ISO datetime 문자열 등으로 저장; 타임존 고려하여 변환)
  * `is_incoming`: 수신/발신 여부 플래그 (예: 본인 발신=False, 상대방 발신(True) 또는 방향을 나타내는 필드).
  * `attachment_info`: **첨부파일 정보**에 대한 참조 또는 메타데이터. (현재는 텍스트 이외 메시지의 경우 타입 식별자나 파일 경로 등의 정보만 기록. 예: 이미지 메시지라면 "image" 같은 타입 표기 또는 파일명. 초기 버전에선 빈 값이거나 간단 문자열로 표시하고, 실제 파일 저장은 추후 구현.)

테이블 간 관계는 `rooms.room_id = messages.room_id`로 연결된다. 이외에도 필요한 경우 **인덱스(index)**를 생성하여 조회 성능을 높일 수 있다 (예: `rooms`의 `room_id`나 `messages`의 `timestamp` 등에 인덱스).

**참고:** macOS 카카오톡의 원본 데이터베이스에서는 모든 채팅방의 메시지가 하나의 테이블(예: `NTChatMessage`)에 통합 저장되는 것으로 알려져 있다. 본 스크립트는 이러한 구조를 이해하고 있어야 하지만, 출력 DB에서는 **사용자 친화적 설계**를 위해 채팅방 정보와 메시지 정보를 분리했다. 향후 첨부파일이나 사용자(친구) 정보 등을 저장하려면 별도의 테이블(`attachments`, `users` 등)을 추가하여 확장할 예정이다.

## 암호화 키 처리 방식

**3. SQLCipher 암호화된 DB 키 획득 및 사용:** 카카오톡 Mac용 DB는 **SQLCipher**로 암호화되어 있으며, **복호화 키**는 사용자의 고유 정보로부터 파생된다. 스크립트는 적절한 키를 생성 또는 입력받아 DB를 복호화해야 한다. 키 처리에 대한 세부 요구사항은 다음과 같다:

* **키 파생 알고리즘:** 카카오톡은 **사용자 ID**와 **디바이스 UUID** 등을 조합하여 **PBKDF2** 등의 방식으로 키를 생성하는 것으로 알려져 있다. 기존 분석에 따르면, HMAC-SHA256 기반 PBKDF2를 100,000회 반복하여 256-bit 길이의 키를 생성하며, salt 값과 패스워드 문자열에 사용자 ID와 장치 UUID (일부 변형한 값)를 활용하는 방식이다.

  * 예를 들어, 기기 UUID에 SHA-1과 SHA-256을 적용한 해시(`hashedDeviceUUID`)와 사용자 ID 등의 조합 문자열을 뒤집는 등의 변형이 사용된다. 이러한 알고리즘 세부사항은 구현 시 참고하며, **정확한 알고리즘이 불확실한 경우**를 대비해 유연성을 둔다.
  * SQLCipher 버전 호환: 카카오톡 DB는 **SQLCipher 3.x** 호환 설정으로 암호화되어 있을 가능성이 높으므로, 복호화 시 **`PRAGMA cipher_default_compatibility = 3`** 설정 후 키를 적용한다. 이를 통해 SQLCipher 최신 버전에서도 옛 버전으로 암호화된 DB를 열 수 있게 한다.

* **키 입력 옵션:** 사용자가 **자신의 User ID나 디바이스 UUID 값을 모를 수 있다**. 실제 KakaoTalk **내부 UserID는 카카오 서버에서 관리되는 고유값**이며 로컬에는 평문 형태로 저장되지 않을 수 있다. 따라서 스크립트는 다양한 방식으로 키를 얻을 수 있어야 한다:

  1. **외부 인자 입력:** 사용자로부터 **User ID와 UUID를 인자**로 받아 PBKDF2 알고리즘으로 키를 생성한다. (예: CLI 옵션으로 `--userid 123456789 --uuid <uuid값>` 제공)
  2. **직접 키 입력:** 만약 사용자가 이미 **복호화 키 문자열**(hex 또는 base64) 자체를 알고 있다면, 그것을 직접 입력할 수 있다. 이 경우 내부적으로 PBKDF2를 수행하지 않고, 제공된 키를 바로 SQLCipher에 적용한다.
  3. **자동 추출 시도:** 가능하다면 스크립트가 **로컬 환경에서 User ID/UUID를 추론 또는 검색**한다. 예를 들어:

     * **설정 파일/캐시 검사:** KakaoTalk 설치 경로나 설정 파일(예: Preferences plist 등)에 사용자 계정이나 디바이스 식별자가 저장되어 있는지 확인한다.
     * **키체인(Keychain) 검사:** macOS Keychain에 KakaoTalk 관련 항목이 저장되어 있다면, 거기서 `UUID`나 세션 키 정보를 얻는 방법을 시도한다. (이 부분은 연구가 더 필요하며, 구현 시 kakao 관련 Keychain entry를 조회하는 코드를 통해 시도할 수 있음)
     * **DB 파일명 이용:** KakaoTalk Mac의 DB 파일 이름 자체가 **키 유도값**으로 생성된 문자열일 수 있다. 만약 DB 파일명을 알고 있다면, 이를 역으로 분석해 일부 정보를 추정할 수 있으나 이는 복잡하므로 우선 고려하지 않는다.

* **키 생성 실패 대응:** 자동 방식으로 키 파생에 실패하거나 잘못된 값을 입력한 경우, **복호화 키를 수동 주입**할 수 있게 한다. 예를 들어 `--key <hexstring>` 옵션을 제공하며, 이 경우 내부적으로 PRAGMA KEY만 설정한다. 키가 올바르지 않으면 DB 조회 시 에러가 발생하므로, 사용자에게 **키 불일치 오류**를 안내한다.

* **보안 고려:** 복호화 키 또는 사용자 ID/UUID 등 민감정보를 다루므로, 스크립트 내에 **로그로 해당 값을 남기지 않는다**. 콘솔 로그에 키를 직접 출력하지 않으며, 필요 시 마스킹하거나 디버그 모드에서만 출력한다. 또한, 키 파생을 위해 입력받은 정보는 **프로그램 종료 후 메모리에서 지워지거나** GC에 맡겨진다 (명시적으로 메모리 초기화는 어려우나, 변수 scope 최소화 등으로 대비).

요약하면, **스크립트는 가능한 한 자동으로 키를 확보**하되, 필요시 사용자가 제공할 수 있는 인터페이스를 마련하여 **유연성**을 제공한다. 키 파생에는 카카오톡이 사용하는 알고리즘(PBKDF2-HMAC-SHA256 등)을 적용하고, **SQLCipher 설정**을 적절히 맞추어 복호화한다.

## 실행 방식 및 CLI 인터페이스

**4. 터미널 실행 형태:** 본 도구는 macOS 터미널에서 사용되는 **CLI (Command Line Interface) 파이썬 스크립트**로 개발된다. 사용자는 필요한 인자를 제공하여 스크립트를 실행하며, 스크립트는 **지정된 위치에 결과 SQLite DB를 생성**한다. 실행 관련 요구사항 상세는 다음과 같다:

* **실행 커맨드 예시:** 스크립트 파일명을 `kakao_decrypt.py`라고 가정하면, 사용 예시는 아래와 같다:

  ```bash
  python kakao_decrypt.py \
    --input "/Users/onset/Library/Containers/com.kakao.KakaoTalkMac/Data/Library/Application Support/com.kakao.KakaoTalkMac/<EncryptedDBFile>" \
    --output "/Users/onset/Desktop/kakao_decrypted.db" \
    --userid 123456789 --uuid "abcd-efgh-ijkl-...." 
  ```

  위 명령은 `--input`으로 암호화된 원본 DB 파일 경로, `--output`으로 결과 SQLite 파일 경로를 지정하고, 사용자 ID와 UUID를 제공하여 키를 파생하는 경우이다. 만약 키를 직접 제공할 때는 `--key <hexKey>` 옵션을 대신 사용할 수 있다.

* **필수/선택 인자:**

  * `--input (-i) <경로>`: **(필수)** 암호화된 KakaoTalk DB 파일의 경로. 보통 Application Support의 해당 파일 위치이며, 사용자가 Finder 등으로 확인하여 넣을 수 있음. 이 값이 없으면 스크립트 실행 불가 (에러 처리).
  * `--output (-o) <경로>`: **(선택)** 출력으로 생성할 SQLite DB 파일 경로. 지정하지 않으면 기본값으로 현재 경로에 `kakao_decrypted.sqlite` (혹은 `.db`) 이름으로 생성한다. 지정한 경로에 이미 파일이 존재하면 덮어쓰기 전에 경고하거나 실패 옵션을 둘 수 있다 (예: `--force` 플래그로 덮어쓰기 허용).
  * **키 관련 인자 (둘 중 하나는 제공 필요):**

    * `--userid <ID>` 및 `--uuid <UUID>`: KakaoTalk 사용자 ID와 기기 UUID. 두 값 모두 제공되어야 키 파생이 가능하다. 하나만 있을 경우 불충분하므로 오류 처리한다.
    * `--key <hex>`: 복호화에 사용할 **SQLCipher 키**를 16진 문자열(hex)로 직접 입력. 이 옵션이 주어지면 `--userid/--uuid`는 무시하거나 받을 필요 없음. (만약 둘 다 주어졌다면 직접 키 우선 사용 혹은 오류 처리; 설계 결정 사항)
  * 기타 옵션:

    * `--verbose (-v)`: 상세 로그 출력 모드. 지정하면 실행 중 추가적인 정보(예: 진행 과정, 디버그 정보)를 콘솔에 표시한다.
    * `--help (-h)`: 사용법 안내. 잘못된 인자로 실행하거나 `-h` 지정 시 지원되는 옵션과 간단 설명을 출력한다.

* **실행 과정:** 스크립트는 인자를 파싱한 후 다음 단계를 수행한다:

  1. **DB 파일 로드:** `--input` 경로의 파일을 확인. 존재하지 않으면 즉시 오류 반환(메시지 출력 후 종료).
  2. **키 확보:** `--key`가 제공된 경우 그 값을 사용, 아니면 `--userid`+`--uuid`로 PBKDF2 키를 생성. (자동추출 기능이 있다면, 인자 미제공 시 내부에서 시도하고 성공하면 진행)
  3. **DB 연결 및 복호화:** `pysqlcipher3` 등의 라이브러리를 사용하여 DB에 접속하고, SQLCipher 호환성/키 설정(PRAGMA)을 수행. 키가 올바르다면 평문 질의가 가능해진다.
  4. **데이터 조회 및 변환:** 원본 DB에서 필요한 컬럼들을 SELECT로 조회. 예를 들어 `NTChatMessage` 테이블에서 메시지 정보, 관련 채팅방 ID 등을 가져온다. 동시에 다른 테이블(채팅방 목록 등)이 있으면 조인하거나 별도 조회하여 `rooms` 정보도 수집.
  5. **출력 DB 생성:** SQLite 기본 라이브러리를 사용하여 출력 경로에 새 DB 파일을 만들고, 미리 정의된 스키마대로 `rooms` 및 `messages` 테이블을 생성한다.
  6. **데이터 삽입:** 추출된 데이터를 새로운 DB에 INSERT한다. 한 번에 메모리에 모두 올리지 않고 **스트리밍 방식**(예: 일정 단위로 fetch하여 commit)으로 처리하여 대용량 데이터에도 대응한다. 메시지 건수가 많을 수 있으므로 **트랜잭션 관리**를 통해 성능을 높이고자 한다.
  7. **완료 처리:** 모든 작업이 끝나면 DB 연결을 닫고, 사용자에게 완료 메시지를 출력한다.

* **로그 및 콘솔 출력:**

  * **성공 시:** 콘솔에 중요한 요약 정보 표시. 예: "복호화 성공: 5개 채팅방, 총 12450개의 메시지를 추출했습니다. 출력 DB: kakao_decrypted.db"와 같이 결과를 알려준다. 추가로 실행에 소요된 시간, 누락된 항목 수(만약 첨부 미처리 메시지 수) 등을 표시할 수 있다.
  * **오류/경고 시:** 문제 발생 시 콘솔에 **명확한 오류 메시지**를 출력한다. 예를 들어:

    * 입력 파일 경로 오류: "입력 DB 파일을 찾을 수 없습니다: <경로>".
    * 키 관련 오류: "복호화 키 생성 실패: 사용자 ID 또는 UUID가 잘못되었거나 키가 유효하지 않습니다.".
    * DB 복호화 오류: "DB 복호화에 실패했습니다. 키 정보가 맞는지 확인해주세요." (키 불일치나 DB 손상 등 원인).
    * 출력 쓰기 오류: "출력 DB에 데이터를 쓰는 중 오류 발생: <상세원인>".
  * **진행 로그:** `--verbose` 모드에서는 각 단계별 진행사항을 알려준다. 예: "키 파생 중...", "원본 DB에서 메시지 1000건 읽는 중...", "출력 DB에 메시지 1000건 저장 완료..." 등. 일반 모드에서는 복호화 성공/실패와 결과 요약 정도만 표시한다.

  실행 방식은 최대한 **사용자 친화적**으로 한다. 명령어 인자 조합이 잘못되었을 경우 친절한 사용법을 안내하고 종료하며, **중요 정보는 요약하여 한눈에 볼 수 있게** 출력한다.

## 코드 구조 및 확장성 고려

**5. 모듈화된 코드 구조:** 이 스크립트의 초기 목적은 개인 데이터 확인용이지만, 향후 데이터 분석 파이프라인에 연결하거나 기능을 확장하기 쉽도록 **코드 구조를 모듈화**한다. 이를 위해 다음과 같은 설계를 고려한다:

* **모듈/함수 분리:** 주요 기능별로 함수를 분리하고, 필요하면 모듈화를 진행한다. 예를 들면:

  * `def derive_key(user_id, uuid):` – 주어진 사용자 ID와 UUID로 PBKDF2 알고리즘을 적용해 복호화 키를 생성. (내부적으로 hashlib.pbkdf2_hmac 등 사용)
  * `def open_encrypted_db(file_path, key_hex):` – 지정한 파일을 SQLCipher로 열고 키를 적용하여 커넥션을 반환. (pysqlcipher3 이용, PRAGMA 설정 포함)
  * `def export_messages(cursor, dest_conn):` – 열린 원본 DB 커서에서 메시지 데이터를 SELECT하여 출력 DB 커넥션에 INSERT. 대용량일 경우 fetchmany 사용 등.
  * `def export_rooms(cursor, dest_conn):` – 채팅방 정보를 SELECT 후 출력 DB에 INSERT. (또는 메시지 처리 중 채팅방 정보를 수집하여 한번에 처리)
  * `def main():` – 인자 파싱(argparse 사용) 및 전체 흐름 제어. 입력 검증 -> 키 확보 -> DB 연결 -> 데이터 추출/삽입 -> 종료.

  이와 같이 함수 단위를 나누면, 특정 부분(예: 키 파생 알고리즘)을 수정하거나 대체하기 쉬워진다. 또한 후에 이미지/첨부파일 처리 함수를 추가하는 등 **유지보수와 확장에 유리**하다.

* **모듈 의존성 관리:** 외부 라이브러리는 필요한 경우 사용하되 (`pysqlcipher3`, `cryptography` 등), 이를 **`requirements.txt`**로 명시하여 환경 세팅을 돕는다. 예를 들어 requirements.txt에는:

  ```
  pysqlcipher3==1.0.3   # SQLCipher DB 접속 라이브러리
  ```

  와 같이 필요한 패키지와 버전을 기록한다. 사용자는 `pip install -r requirements.txt`로 쉽게 설치할 수 있다. 또한 표준 라이브러리 (hashlib 등)는 바로 사용하고, OS 종속적인 기능(Keychain 접근 등)은 플랫폼 체크 후 호출한다.

* **코드 스타일:** PEP8 스타일을 준수하고, 함수/변수 이름은 역할이 드러나게 짓는다 (예: `derive_key`, `decrypt_database`). 주요 함수에는 docstring으로 동작을 설명하고, 복잡한 알고리즘 (예: 키 파생)에는 주석으로 출처나 근거를 명시해 둔다 (예: "## KakaoTalk key derivation logic: PBKDF2(HMAC-SHA256, iter=100k)..." 등 주석).

* **향후 확장 계획:** 초기에는 텍스트 메시지 복호화에 중점을 두지만, 코드 구조를 유연하게 만들어 다음 기능 추가가 용이하도록 고려한다:

  * 첨부파일(이미지, 영상 등) 추출: 첨부파일 경로나 바이너리를 가져와 로컬 파일로 저장하고, 출력 DB에 해당 파일 경로나 식별자를 추가하는 기능. 이를 위해 메시지 테이블의 `attachment_info` 필드를 이미 준비해 두었으며, 향후 `attachments`라는 별도 테이블(필드: 파일ID, 유형, 원본파일명, 경로 등)로 분리 저장 가능.
  * **사용자 정보 매핑:** sender_id 등이 단순 숫자일 경우 사용자가 알아보기 어렵기 때문에, 추후 사용자(친구) 프로필 정보를 가져와 `users` 테이블에 저장하고, 메시지의 sender를 참조하게 할 수 있다. (예: 친구 이름, KakaoTalk 프로필 이미지 등도 추후 가능하면 포함)
  * **대화방 설정 및 기타 메타데이터:** 예를 들어 채팅방의 공지사항, 마지막 읽은 메시지 번호, 멤버 리스트 등 추가 정보를 원본 DB에서 추출하여 필요시 새로운 테이블 생성 가능. 초기에는 다루지 않음.
  * **크로스 플랫폼:** 현재 macOS 경로와 구조에 맞춰 설계하지만, Windows KakaoTalk의 DB 복호화와 구조도 유사하게 확장 가능하도록 추상화한다. (예: 파일 경로 구분자나 DB 파일 위치 등의 차이를 제외하고 로직은 대부분 재사용 가능하도록)

  이러한 확장 시나리오를 염두에 두고, **코드의 응집도와 결합도를 관리**한다. 예를 들어, 현재는 macOS 전용이지만 플랫폼 분기를 두어 Windows 지원을 추가하거나, DB 스키마 정의를 별도 config로 분리하여 구조 변화에 대응하기 쉽게 할 수 있다.

* **성능 및 대용량 대응:** 수만 건 이상의 메시지도 처리할 수 있도록 효율에 신경쓴다. 가능한 한 한 번에 너무 많은 데이터를 메모리에 올리지 않고, **커서 스트리밍**이나 배치 Insert 등을 사용한다. 필요시 tqdm 같은 라이브러리로 진행률 표시를 고려할 수 있다 (요구사항에는 없지만 사용자 경험 개선점). 또한, SQLite 쓰기 시 속도를 위해 **트랜잭션**을 사용하고, 완료 후 `ANALYZE`나 `INDEX` 추가도 고려한다.

요약하면 코드 구조는 **유지보수성, 확장성, 재사용성**을 높이는 방향으로 구현한다. 모듈화를 통해 이후 기능 추가 시 기본 구조를 해치지 않고도 보완할 수 있으며, 각 컴포넌트는 단일 책임을 갖도록 구현한다.

## 예외 및 오류 처리 시나리오

견고한 스크립트를 위해 **예외 상황에 대한 처리**가 중요하다. 아래는 예상 가능한 예외/오류 시나리오와 그에 대한 처리 방안을 정리한다:

* **입력 파일 경로 오류:** 사용자 입력 경로에 DB 파일이 없거나 잘못 지정된 경우:

  * 증상: `--input` 경로에 해당 파일이 없음. `os.path.exists` 체크나 파일 열기 시 에러 발생.
  * 처리: 즉시 "[Error] 지정된 DB 파일을 찾을 수 없습니다: <경로>" 라는 메시지를 출력하고 프로그램을 종료한다 (exit code != 0). `--help` 옵션 안내를 추가로 표시하여 올바른 사용법을 재공지할 수도 있다.

* **출력 경로 오류:** 출력 파일 경로 폴더가 존재하지 않거나 쓰기 권한이 없는 경우:

  * 증상: SQLite 출력 파일 생성 시 IOError/OS error.
  * 처리: "[Error] 출력 경로에 파일을 생성할 수 없습니다: <경로> (권한 혹은 경로 확인)" 등의 메시지를 보여주고 종료. 사용자가 경로를 다시 확인하도록 유도. 만약 동일 이름 파일이 이미 있어 덮어쓰기 문제가 발생하면, 기본적으로 덮어쓰지 않고 오류 표시 (`--force` 옵션이 있는 경우에만 덮어씀).

* **키 파생 입력 오류:** 사용자 ID 또는 UUID를 제공했으나 형식이 잘못된 경우:

  * 증상: `--userid`나 `--uuid` 값이 숫자나 올바른 형식이 아닐 경우 (예: 문자열 대신 숫자가 와야 하는데 문자, 또는 UUID 자릿수 틀림).
  * 처리: 인자 파싱 시 형식을 검증하여 문제가 있으면 "[Error] 사용자 ID 또는 UUID 형식이 잘못되었습니다." 출력. UUID는 일반적으로 하이픈 포함 36자 형태 등으로 예상하고, 정규식으로 검증할 수 있다. ID는 숫자만인지 확인. 오류시 키 파생을 시도하지 않고 종료.

* **키 파생 실패/키 불일치:** 입력받은 정보로 PBKDF2 키를 생성했으나 DB 복호화에 실패하는 경우:

  * 증상: `PRAGMA KEY` 적용 후 DB 쿼리에 접근할 때 **SQLCipher**에서 `database not open` 또는 디크립션 관련 오류를 던짐, 혹은 조회 결과가 엉뚱하게 나옴.
  * 원인: 잘못된 사용자 ID/UUID로 잘못된 키 생성, 또는 `--key`로 잘못된 값을 입력.
  * 처리: 첫 번째 쿼리(예: 테이블 목록 조회 또는 간단한 SELECT)를 시도한 뒤 오류를 감지하면, "[Error] DB 복호화 실패: 제공된 키 정보가 올바르지 않습니다." 라고 출력하고 종료. 이때 원인이 키일 가능성이 높으므로, 사용자에게 ID/UUID 확인 또는 `--key` 직접 입력을 재시도하도록 안내한다. (디버그 모드에서는 추가로 내부 오류 메시지 출력 가능)

* **원본 DB 구조 변화:** 카카오톡 애플리케이션 업데이트로 DB 테이블 명이나 구조가 바뀐 경우:

  * 증상: 예를 들어 `NTChatMessage` 테이블을 찾을 수 없다는 오류, 또는 컬럼명이 달라 쿼리가 실패.
  * 처리: "[Error] 예상된 데이터베이스 스키마와 일치하지 않습니다. KakaoTalk 버전을 확인해주세요." 등의 메시지 출력. 이 경우 업데이트에 따른 스크립트 수정이 필요함을 알리고 종료. (향후 개선으로, 테이블 목록을 조회해 비슷한 이름을 찾는 등의 유연성 고려 가능)

* **데이터 삽입 중 오류:** 출력 SQLite DB에 데이터를 INSERT하다가 무결성 제약 등 오류가 발생한 경우:

  * 예: 메시지 PK 충돌 (이론적으로 원본 PK를 그대로 쓰면 충돌 없겠지만, 여러 DB 병합 시나리오에서는 있을 수 있음), 또는 예상치 못한 NULL 제약 위반 등.
  * 처리: 문제가 되는 레코드 정보를 로그로 남기고, 가능한 한 **계속 진행**하도록 한다. 예컨대 하나의 INSERT 실패 시 해당 메시지를 건너뛰고 로그에 "[Warn] 메시지 ID XXX 삽입 실패 (무시하고 계속): <오류원인>" 기록. 모든 데이터를 다 건너뛸 수 없을 정도의 치명적 오류라면 종료하되, 그렇지 않다면 최대한 **나머지 처리는 이어서** 한다. 완료 후 경고를 모아서 요약 보고.

* **환경 의존 오류:** 파이썬 실행 환경이나 라이브러리 이슈:

  * 예: `pysqlcipher3` 설치 안됨 또는 ImportError.
  * 처리: 스크립트 시작 시 try/except ImportError로 잡아서 "필요한 라이브러리(pysqlcipher3)가 설치되지 않았습니다. 'pip install pysqlcipher3'로 설치 후 다시 시도해주세요." 안내 후 종료. 또한 Python 버전이 너무 낮아(예: <3.6) 작동 안할 경우 버전 체크 후 "Python 3.7 이상에서 실행해주세요." 등 안내.
  * 만약 macOS 외 OS에서 실행하려 할 경우 (지원하지 않는 상황): "이 스크립트는 macOS 환경에서만 동작합니다." 라고 출력 (platform 체크)하고 종료할 수 있다.

* **메모리/성능 문제:** 매우 방대한 대화 내역으로 인한 메모리 부족 등:

  * 처리: 기본적으로는 fetchmany 사용 등으로 메모리 사용을 제어하지만, 만약 한 채팅방에 메시지가 수백만 건 단위라면 프로세스가 느려지거나 메모리 커질 수 있다. 이 경우를 대비해 `--limit` 같은 옵션으로 일부만 추출하거나, 경고를 출력한다. (예: "데이터 양이 많아 처리가 오래 걸릴 수 있습니다...").

모든 오류/예외 메시지는 **한글로 이해하기 쉽게** 작성하고, 필요시 해결 방법을 함께 제시한다. 예를 들어 키 에러의 경우 "카카오톡 PC 앱의 UUID 확인 방법은 ...", 라이브러리 에러의 경우 "requirements.txt를 확인하세요" 등의 추가 팁을 줄 수 있다. 이러한 친절한 안내를 통해 사용자가 문제를 스스로 해결하고 스크립트를 활용할 수 있도록 돕는다.

---

본 PRD에 제시된 요구사항과 설계 방향을 토대로 개발을 진행하면, macOS 환경에서 KakaoTalk 대화 내용을 안전하게 복호화하여 활용할 수 있는 Python 스크립트를 구현할 수 있다. 요구사항에 명시되지 않은 세부 구현은 개발자의 판단에 따라 이루어지겠지만, **데이터 보존의 완전성**, **사용 편의성**, **코드의 확장성**을 최우선 원칙으로 고려한다.
